// Code generated by mockery v2.53.5. DO NOT EDIT.

package infrastructure_mock

import (
	context "context"

	clause "gorm.io/gorm/clause"

	dao "user-domain/infrastructure/persistence/postgres/dao"

	field "gorm.io/gen/field"

	gen "gorm.io/gen"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	model "user-domain/infrastructure/persistence/postgres/model"

	schema "gorm.io/gorm/schema"
)

// ISchemaMigrationDo is an autogenerated mock type for the ISchemaMigrationDo type
type ISchemaMigrationDo struct {
	mock.Mock
}

// As provides a mock function with given fields: alias
func (_m *ISchemaMigrationDo) As(alias string) gen.Dao {
	ret := _m.Called(alias)

	if len(ret) == 0 {
		panic("no return value specified for As")
	}

	var r0 gen.Dao
	if rf, ok := ret.Get(0).(func(string) gen.Dao); ok {
		r0 = rf(alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Dao)
		}
	}

	return r0
}

// Assign provides a mock function with given fields: attrs
func (_m *ISchemaMigrationDo) Assign(attrs ...field.AssignExpr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Assign")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) dao.ISchemaMigrationDo); ok {
		r0 = rf(attrs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Attrs provides a mock function with given fields: attrs
func (_m *ISchemaMigrationDo) Attrs(attrs ...field.AssignExpr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Attrs")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) dao.ISchemaMigrationDo); ok {
		r0 = rf(attrs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// BeCond provides a mock function with no fields
func (_m *ISchemaMigrationDo) BeCond() interface{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BeCond")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Clauses provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Clauses(conds ...clause.Expression) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Clauses")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...clause.Expression) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Columns provides a mock function with given fields: cols
func (_m *ISchemaMigrationDo) Columns(cols ...field.Expr) gen.Columns {
	_va := make([]interface{}, len(cols))
	for _i := range cols {
		_va[_i] = cols[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Columns")
	}

	var r0 gen.Columns
	if rf, ok := ret.Get(0).(func(...field.Expr) gen.Columns); ok {
		r0 = rf(cols...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Columns)
		}
	}

	return r0
}

// CondError provides a mock function with no fields
func (_m *ISchemaMigrationDo) CondError() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CondError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Count provides a mock function with no fields
func (_m *ISchemaMigrationDo) Count() (int64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func() (int64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: values
func (_m *ISchemaMigrationDo) Create(values ...*model.SchemaMigration) error {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...*model.SchemaMigration) error); ok {
		r0 = rf(values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateInBatches provides a mock function with given fields: values, batchSize
func (_m *ISchemaMigrationDo) CreateInBatches(values []*model.SchemaMigration, batchSize int) error {
	ret := _m.Called(values, batchSize)

	if len(ret) == 0 {
		panic("no return value specified for CreateInBatches")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]*model.SchemaMigration, int) error); ok {
		r0 = rf(values, batchSize)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Debug provides a mock function with no fields
func (_m *ISchemaMigrationDo) Debug() dao.ISchemaMigrationDo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Debug")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func() dao.ISchemaMigrationDo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Delete provides a mock function with given fields: _a0
func (_m *ISchemaMigrationDo) Delete(_a0 ...*model.SchemaMigration) (gen.ResultInfo, error) {
	_va := make([]interface{}, len(_a0))
	for _i := range _a0 {
		_va[_i] = _a0[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(...*model.SchemaMigration) (gen.ResultInfo, error)); ok {
		return rf(_a0...)
	}
	if rf, ok := ret.Get(0).(func(...*model.SchemaMigration) gen.ResultInfo); ok {
		r0 = rf(_a0...)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(...*model.SchemaMigration) error); ok {
		r1 = rf(_a0...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Distinct provides a mock function with given fields: cols
func (_m *ISchemaMigrationDo) Distinct(cols ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(cols))
	for _i := range cols {
		_va[_i] = cols[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Distinct")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(cols...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Find provides a mock function with no fields
func (_m *ISchemaMigrationDo) Find() ([]*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 []*model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByPage provides a mock function with given fields: offset, limit
func (_m *ISchemaMigrationDo) FindByPage(offset int, limit int) ([]*model.SchemaMigration, int64, error) {
	ret := _m.Called(offset, limit)

	if len(ret) == 0 {
		panic("no return value specified for FindByPage")
	}

	var r0 []*model.SchemaMigration
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]*model.SchemaMigration, int64, error)); ok {
		return rf(offset, limit)
	}
	if rf, ok := ret.Get(0).(func(int, int) []*model.SchemaMigration); ok {
		r0 = rf(offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int64); ok {
		r1 = rf(offset, limit)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(offset, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindInBatch provides a mock function with given fields: batchSize, fc
func (_m *ISchemaMigrationDo) FindInBatch(batchSize int, fc func(gen.Dao, int) error) ([]*model.SchemaMigration, error) {
	ret := _m.Called(batchSize, fc)

	if len(ret) == 0 {
		panic("no return value specified for FindInBatch")
	}

	var r0 []*model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func(int, func(gen.Dao, int) error) ([]*model.SchemaMigration, error)); ok {
		return rf(batchSize, fc)
	}
	if rf, ok := ret.Get(0).(func(int, func(gen.Dao, int) error) []*model.SchemaMigration); ok {
		r0 = rf(batchSize, fc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func(int, func(gen.Dao, int) error) error); ok {
		r1 = rf(batchSize, fc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindInBatches provides a mock function with given fields: result, batchSize, fc
func (_m *ISchemaMigrationDo) FindInBatches(result *[]*model.SchemaMigration, batchSize int, fc func(gen.Dao, int) error) error {
	ret := _m.Called(result, batchSize, fc)

	if len(ret) == 0 {
		panic("no return value specified for FindInBatches")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]*model.SchemaMigration, int, func(gen.Dao, int) error) error); ok {
		r0 = rf(result, batchSize, fc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// First provides a mock function with no fields
func (_m *ISchemaMigrationDo) First() (*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 *model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() (*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FirstOrCreate provides a mock function with no fields
func (_m *ISchemaMigrationDo) FirstOrCreate() (*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstOrCreate")
	}

	var r0 *model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() (*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FirstOrInit provides a mock function with no fields
func (_m *ISchemaMigrationDo) FirstOrInit() (*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstOrInit")
	}

	var r0 *model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() (*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Group provides a mock function with given fields: cols
func (_m *ISchemaMigrationDo) Group(cols ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(cols))
	for _i := range cols {
		_va[_i] = cols[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Group")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(cols...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Having provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Having(conds ...gen.Condition) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Having")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...gen.Condition) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Join provides a mock function with given fields: table, on
func (_m *ISchemaMigrationDo) Join(table schema.Tabler, on ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(on))
	for _i := range on {
		_va[_i] = on[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, table)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(schema.Tabler, ...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(table, on...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Joins provides a mock function with given fields: fields
func (_m *ISchemaMigrationDo) Joins(fields ...field.RelationField) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Joins")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.RelationField) dao.ISchemaMigrationDo); ok {
		r0 = rf(fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Last provides a mock function with no fields
func (_m *ISchemaMigrationDo) Last() (*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Last")
	}

	var r0 *model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() (*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeftJoin provides a mock function with given fields: table, on
func (_m *ISchemaMigrationDo) LeftJoin(table schema.Tabler, on ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(on))
	for _i := range on {
		_va[_i] = on[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, table)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LeftJoin")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(schema.Tabler, ...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(table, on...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Limit provides a mock function with given fields: limit
func (_m *ISchemaMigrationDo) Limit(limit int) dao.ISchemaMigrationDo {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(int) dao.ISchemaMigrationDo); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Not provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Not(conds ...gen.Condition) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Not")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...gen.Condition) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Offset provides a mock function with given fields: offset
func (_m *ISchemaMigrationDo) Offset(offset int) dao.ISchemaMigrationDo {
	ret := _m.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for Offset")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(int) dao.ISchemaMigrationDo); ok {
		r0 = rf(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Omit provides a mock function with given fields: cols
func (_m *ISchemaMigrationDo) Omit(cols ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(cols))
	for _i := range cols {
		_va[_i] = cols[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Omit")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(cols...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Or provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Or(conds ...gen.Condition) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Or")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...gen.Condition) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Order provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Order(conds ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Order")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Pluck provides a mock function with given fields: column, dest
func (_m *ISchemaMigrationDo) Pluck(column field.Expr, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Pluck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(field.Expr, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Preload provides a mock function with given fields: fields
func (_m *ISchemaMigrationDo) Preload(fields ...field.RelationField) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Preload")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.RelationField) dao.ISchemaMigrationDo); ok {
		r0 = rf(fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Returning provides a mock function with given fields: value, columns
func (_m *ISchemaMigrationDo) Returning(value interface{}, columns ...string) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Returning")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(interface{}, ...string) dao.ISchemaMigrationDo); ok {
		r0 = rf(value, columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// RightJoin provides a mock function with given fields: table, on
func (_m *ISchemaMigrationDo) RightJoin(table schema.Tabler, on ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(on))
	for _i := range on {
		_va[_i] = on[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, table)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RightJoin")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(schema.Tabler, ...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(table, on...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Save provides a mock function with given fields: values
func (_m *ISchemaMigrationDo) Save(values ...*model.SchemaMigration) error {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...*model.SchemaMigration) error); ok {
		r0 = rf(values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Scan provides a mock function with given fields: result
func (_m *ISchemaMigrationDo) Scan(result interface{}) error {
	ret := _m.Called(result)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ScanByPage provides a mock function with given fields: result, offset, limit
func (_m *ISchemaMigrationDo) ScanByPage(result interface{}, offset int, limit int) (int64, error) {
	ret := _m.Called(result, offset, limit)

	if len(ret) == 0 {
		panic("no return value specified for ScanByPage")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int) (int64, error)); ok {
		return rf(result, offset, limit)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int) int64); ok {
		r0 = rf(result, offset, limit)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int) error); ok {
		r1 = rf(result, offset, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Scopes provides a mock function with given fields: funcs
func (_m *ISchemaMigrationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(funcs))
	for _i := range funcs {
		_va[_i] = funcs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Scopes")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...func(gen.Dao) gen.Dao) dao.ISchemaMigrationDo); ok {
		r0 = rf(funcs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Select provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Select(conds ...field.Expr) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...field.Expr) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// TableName provides a mock function with no fields
func (_m *ISchemaMigrationDo) TableName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TableName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Take provides a mock function with no fields
func (_m *ISchemaMigrationDo) Take() (*model.SchemaMigration, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Take")
	}

	var r0 *model.SchemaMigration
	var r1 error
	if rf, ok := ret.Get(0).(func() (*model.SchemaMigration, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *model.SchemaMigration); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SchemaMigration)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnderlyingDB provides a mock function with no fields
func (_m *ISchemaMigrationDo) UnderlyingDB() *gorm.DB {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for UnderlyingDB")
	}

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// Unscoped provides a mock function with no fields
func (_m *ISchemaMigrationDo) Unscoped() dao.ISchemaMigrationDo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Unscoped")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func() dao.ISchemaMigrationDo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// Update provides a mock function with given fields: column, value
func (_m *ISchemaMigrationDo) Update(column field.Expr, value interface{}) (gen.ResultInfo, error) {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(field.Expr, interface{}) (gen.ResultInfo, error)); ok {
		return rf(column, value)
	}
	if rf, ok := ret.Get(0).(func(field.Expr, interface{}) gen.ResultInfo); ok {
		r0 = rf(column, value)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(field.Expr, interface{}) error); ok {
		r1 = rf(column, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumn provides a mock function with given fields: column, value
func (_m *ISchemaMigrationDo) UpdateColumn(column field.Expr, value interface{}) (gen.ResultInfo, error) {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumn")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(field.Expr, interface{}) (gen.ResultInfo, error)); ok {
		return rf(column, value)
	}
	if rf, ok := ret.Get(0).(func(field.Expr, interface{}) gen.ResultInfo); ok {
		r0 = rf(column, value)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(field.Expr, interface{}) error); ok {
		r1 = rf(column, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumnSimple provides a mock function with given fields: columns
func (_m *ISchemaMigrationDo) UpdateColumnSimple(columns ...field.AssignExpr) (gen.ResultInfo, error) {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumnSimple")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) (gen.ResultInfo, error)); ok {
		return rf(columns...)
	}
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) gen.ResultInfo); ok {
		r0 = rf(columns...)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(...field.AssignExpr) error); ok {
		r1 = rf(columns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumns provides a mock function with given fields: value
func (_m *ISchemaMigrationDo) UpdateColumns(value interface{}) (gen.ResultInfo, error) {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumns")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}) (gen.ResultInfo, error)); ok {
		return rf(value)
	}
	if rf, ok := ret.Get(0).(func(interface{}) gen.ResultInfo); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = rf(value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFrom provides a mock function with given fields: q
func (_m *ISchemaMigrationDo) UpdateFrom(q gen.SubQuery) gen.Dao {
	ret := _m.Called(q)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFrom")
	}

	var r0 gen.Dao
	if rf, ok := ret.Get(0).(func(gen.SubQuery) gen.Dao); ok {
		r0 = rf(q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Dao)
		}
	}

	return r0
}

// UpdateSimple provides a mock function with given fields: columns
func (_m *ISchemaMigrationDo) UpdateSimple(columns ...field.AssignExpr) (gen.ResultInfo, error) {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSimple")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) (gen.ResultInfo, error)); ok {
		return rf(columns...)
	}
	if rf, ok := ret.Get(0).(func(...field.AssignExpr) gen.ResultInfo); ok {
		r0 = rf(columns...)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(...field.AssignExpr) error); ok {
		r1 = rf(columns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Updates provides a mock function with given fields: value
func (_m *ISchemaMigrationDo) Updates(value interface{}) (gen.ResultInfo, error) {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Updates")
	}

	var r0 gen.ResultInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}) (gen.ResultInfo, error)); ok {
		return rf(value)
	}
	if rf, ok := ret.Get(0).(func(interface{}) gen.ResultInfo); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	if rf, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = rf(value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Where provides a mock function with given fields: conds
func (_m *ISchemaMigrationDo) Where(conds ...gen.Condition) dao.ISchemaMigrationDo {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Where")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(...gen.Condition) dao.ISchemaMigrationDo); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// WithContext provides a mock function with given fields: ctx
func (_m *ISchemaMigrationDo) WithContext(ctx context.Context) dao.ISchemaMigrationDo {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 dao.ISchemaMigrationDo
	if rf, ok := ret.Get(0).(func(context.Context) dao.ISchemaMigrationDo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.ISchemaMigrationDo)
		}
	}

	return r0
}

// WithResult provides a mock function with given fields: fc
func (_m *ISchemaMigrationDo) WithResult(fc func(gen.Dao)) gen.ResultInfo {
	ret := _m.Called(fc)

	if len(ret) == 0 {
		panic("no return value specified for WithResult")
	}

	var r0 gen.ResultInfo
	if rf, ok := ret.Get(0).(func(func(gen.Dao)) gen.ResultInfo); ok {
		r0 = rf(fc)
	} else {
		r0 = ret.Get(0).(gen.ResultInfo)
	}

	return r0
}

// underlyingDB provides a mock function with no fields
func (_m *ISchemaMigrationDo) underlyingDB() *gorm.DB {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for underlyingDB")
	}

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// underlyingDO provides a mock function with no fields
func (_m *ISchemaMigrationDo) underlyingDO() *gen.DO {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for underlyingDO")
	}

	var r0 *gen.DO
	if rf, ok := ret.Get(0).(func() *gen.DO); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.DO)
		}
	}

	return r0
}

// NewISchemaMigrationDo creates a new instance of ISchemaMigrationDo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewISchemaMigrationDo(t interface {
	mock.TestingT
	Cleanup(func())
}) *ISchemaMigrationDo {
	mock := &ISchemaMigrationDo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
